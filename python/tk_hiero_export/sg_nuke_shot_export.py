# Copyright (c) 2013 Shotgun Software Inc.
# 
# CONFIDENTIAL AND PROPRIETARY
# 
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit 
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your 
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights 
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import sys
import shutil

from PySide import QtGui
from PySide import QtCore

import hiero.core
from hiero.exporters import FnShotExporter
from hiero.exporters import FnShotProcessor
from hiero.exporters import FnNukeShotExporter
import tank
from tank import TankError

from hiero.exporters import FnNukeShotExporterUI

from .base import ShotgunHieroObjectBase

class ShotgunNukeShotExporterUI(FnNukeShotExporterUI.NukeShotExporterUI):
    """
    Custom Preferences UI for the shotgun nuke shot exporter
    """
    
    def __init__(self, preset):
        FnNukeShotExporterUI.NukeShotExporterUI.__init__(self, preset)
        self._displayName = "Shotgun Nuke Project File"
        self._taskType = ShotgunNukeShotExporter


class ShotgunNukeShotExporter(ShotgunHieroObjectBase, FnNukeShotExporter.NukeShotExporter):
    """
    Create Transcode object and send to Shotgun
    """
    
    def __init__(self, initDict):
        """
        Constructor
        """
        FnNukeShotExporter.NukeShotExporter.__init__(self, initDict)
        self._resolved_export_path = None
        self._sequence_name = None
        self._shot_name = None
        self._thumbnail = None
        self._tk_version = None

    # def versionString(self):
    #     """versionString(self)
    #     Returns the version string used to resolve the {version} token

    #     Overridden in order to allow Toolkit to do the version token formatting
    #     to keep things consistent (eg. removing the 'v' from the version string
    #     generated by Hiero)"""
    #     template_path = self.app.tank.templates['hiero_nuke_script_path']
    #     val = int(self._version[1:])
    #     return template_path.keys['version'].str_from_value(val)

    def taskStep(self):
        """
        Run Task
        """
        if self._resolved_export_path is None:
            self._resolved_export_path = self.resolvedExportPath()
            self._shot_name = self.shotName()
            self._sequence_name = self.sequenceName()
            # create context with the info here
            # ctx = self.app.tank.context_from_path(self._resolved_export_path)
            self.app.log_info("TK_VERSION: %s" % self.versionString())
            # access settings for writenode app from shot env and use those settings
            # other_settings = tank.platform.find_app_settings(self._app.engine.name, self._app.name, self._app.tank, context)


            source = self._item.source()
            self._thumbnail = source.thumbnail(source.posterFrame())

        return FnNukeShotExporter.NukeShotExporter.taskStep(self)

    def finishTask(self):
        """
        Finish Task
        """
        # run base class implementation
        FnNukeShotExporter.NukeShotExporter.finishTask(self)

        sg_current_user = tank.util.get_current_user(self.app.tank)

        # register publish
         
        # context we're publishing to
        # ctx = self.app.tank.context_from_path(self._resolved_export_path)
        # self.app.log_info("ACTUAL CONTEXT: %s" % ctx)

        self.app.log_info("EXPORT PATH: %s" % self._resolved_export_path)
        template_path = self.app.tank.template_from_path(self._resolved_export_path)
        self.app.log_info("TEMPLATE: %s" % template_path)
        template_keys = template_path.get_fields(self._resolved_export_path)
        self.app.log_info("TEMPLATE_KEYS: %s" % template_keys)

        args = {
            "tk": self.app.tank,
            "context": self.app.context, 
            # "comment": None,
            "path": self._resolved_export_path,
            "name": os.path.basename(self._resolved_export_path),
            "version_number": template_keys["version"],
            # "dependency_paths": dependency_paths,
            "published_file_type": 'Nuke Script',  # comes from config - try for nuke
        }
                
        # register publish;
        self.app.log_debug("Register publish in shotgun: %s" % str(args))
        sg_data = tank.util.register_publish(**args)

        # upload thumbnail for sequence
        # todo: catch for weirdness
        try:
            self._upload_poster_frame(sg_data, self._project.sequences()[0])
        except IndexError:
            # no sequences!
            self.app.log_warning("Couldn't find sequence to upload thumbnail from")

        
    def _upload_poster_frame(self, sg_entity, source):
        """
        Updates the thumbnail for an entity in Shotgun
        @todo: move this code somewhere where it can be re-used instead of 
               essentially duplicated from ShotgunShotUpdater
        """
        import tempfile
        import uuid

        thumbdir = tempfile.mkdtemp(prefix='hiero_process_nuke_script_')
        try:
            path = "%s.png" % os.path.join(thumbdir, source.name())
            poster = source.posterFrame()
            thumb_qimage = source.thumbnail(poster)
            # scale it down to 600px wide
            thumb_qimage_scaled = thumb_qimage.scaledToWidth(600, QtCore.Qt.SmoothTransformation)
            thumb_qimage_scaled.save(path)
            self.app.log_debug("Uploading thumbnail for %s %s..." % (sg_entity['type'], sg_entity['id']))
            self.app.shotgun.upload_thumbnail(sg_entity['type'], sg_entity['id'], path)
        except Exception, e:
            self.app.log_info("Thumbnail for %s was not refreshed in Shotgun: %s" % (source, e))
        finally:
            shutil.rmtree(thumbdir)

    def _beforeNukeScriptWrite(self, script):
        """Remove existing WriteNodes and replace with Tk WriteNodes
        """
        pass
        return

        self.app.log_debug('SCRIPT: %s' % script)
        self.app.log_debug('SCRIPT dir(): %s' % dir(script))
        
        # find the node to use from the config
        tk_write_node_setting = self.app.get_setting("nuke_write_node_setting")
        if not tk_write_node_setting:
            self.app.log_debug("No Shotgun Nuke write node setting defined in "
                               "the config. No write node will be added.")
            return

        # we will need the write node app to create Shotgun write nodes for the
        # nuke script.
        write_node_app = self.app.engine.apps.get("tk-nuke-writenode")
        if not write_node_app:
            raise TankError("Unable to create write node without tk-nuke-writenode app!")
        tk_write_node = write_node_app.create_write_node(tk_write_node_setting)
        script.add_node(tk_write_node)




class ShotgunNukeShotPreset(ShotgunHieroObjectBase, FnNukeShotExporter.NukeShotPreset):
    """
    Settings for the shotgun transcode step
    """
    
    def __init__(self, name, properties):
        FnNukeShotExporter.NukeShotPreset.__init__(self, name, properties)
        self._parentType = ShotgunNukeShotExporter

    # def addCustomResolveEntries(self, resolver):
    #     resolver.addResolver("{version}", "Version string (without the 'v') defined by Shotgun Toolkit", 
    #                          lambda keyword, task: task.versionString())
  
